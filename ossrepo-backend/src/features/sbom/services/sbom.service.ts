import { Injectable, Logger, Body } from '@nestjs/common';
import { SbomRepository } from '../repositories/sbom.repository';
import { CreateSbomDto } from '../dto/sbom.dto';
import { simpleGit } from 'simple-git';
import { randomUUID } from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import * as Docker from 'dockerode';
import * as os from 'os';
import { stringify } from 'querystring';

interface SBOMComponent {
  'bom-ref': string;
  name: string;
  version: string;
}

interface SBOMDependency {
  ref: string;
  dependsOn: string[];
}

interface SBOM {
  components: SBOMComponent[];
  dependencies: SBOMDependency[];
}



@Injectable()
export class SbomService {

  private readonly logger = new Logger(SbomService.name);
  private readonly docker = new Docker.default();


  constructor(private readonly sbomRepo: SbomRepository) {}

  // Fetch SBOM tied to the watchlist for a user
  async getWatchSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getWatchSbom(user_id);
    return sbomData;
  }

  // Fetch personal SBOM generated by user
  async getUserSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getUserSbom(user_id);
    return sbomData;
  }

  // Clone Git repo into a temp directory
  async cloneRepo(gitUrl: string): Promise<string> {
    const targetDir = path.join(os.tmpdir(), 'sbom-repos');
    const uniqueDir = path.join(targetDir, randomUUID());

    const clonePath = path.resolve(uniqueDir);
    const git = simpleGit();

    try {
      console.log(`Cloning ${gitUrl} into ${clonePath}...`);
      await git.clone(gitUrl, clonePath);
      console.log('Clone complete.');
    } catch (err) {
      console.error('Error cloning repo:', err);
      throw err;
    }
    return uniqueDir;
  }

  // Remove test directories to reduce SBOM noise
  private async cleanupRepo(repoPath: string) {
    const testDirs = ['test', 'tests'];

    for (const dir of testDirs) {
      const fullPath = path.join(repoPath, dir);
      if (fs.existsSync(fullPath)) {
        console.log(`üßπ Removing ${dir}`);
        fs.rmSync(fullPath, { recursive: true, force: true });
      }
    }

  }

  // Run Docker container
  private async runCommand({
    image,
    cmd,
    workingDir,
    volumeHostPath,
    volumeContainerPath = '/app',
    autoRemove = true,
  }: { 
    image: string;
    cmd: string[]; 
    workingDir: string;
    volumeHostPath: string;
    volumeContainerPath?: string;
    autoRemove?: boolean;} ): Promise<void> {
    const container = await this.docker.createContainer({
      Image: image, Cmd: cmd, WorkingDir: workingDir,
      HostConfig: {
        Binds: [`${volumeHostPath}:${volumeContainerPath}`],
        AutoRemove: autoRemove,
      },
    });

    this.logger.log(`Running container with command: ${cmd.join(' ')}`);
    await container.start();

    const stream = await container.logs({ stdout: true, stderr: true, follow: true });
    stream.on('data', (chunk) => this.logger.debug(chunk.toString()));

    const result = await container.wait();
    if (result.StatusCode !== 0) {
      throw new Error(`Container exited with code ${result.StatusCode}`);
    }
  }

  // Generate SBOM using cdxgen inside a container
  async genSbom(repoPath: string): Promise<string> {
    const absPath = path.resolve(repoPath);
    const outputFileName = 'sbom-output1.json';
    const containerPath = '/app';
    const outputPath = path.join(absPath, outputFileName);

    if (!fs.existsSync(absPath)) {
      throw new Error(`Repo path not found: ${absPath}`);
    }
    try {
      // Regular command
      await this.runCommand({
        image: 'ghcr.io/cyclonedx/cdxgen:latest',
        cmd: ['-o', outputFileName],
        workingDir: containerPath,
        volumeHostPath: absPath,
      });
    } catch (err1) {
      this.logger.warn(`cdxgen failed: ${err1.message}, retrying with --no-recurse`);

      try {
        // Retry with --no-recurse
        await this.runCommand({
          image: 'ghcr.io/cyclonedx/cdxgen:latest',
          cmd: ['--no-recurse', '-o', outputFileName],
          workingDir: containerPath,
          volumeHostPath: absPath,
        });
      } catch (err2) {
        this.logger.error(`cdxgen with --no-recurse failed: ${err2.message}. Writing empty SBOM.`);

        // Fallback: write empty SBOM
        fs.writeFileSync(outputPath, JSON.stringify({
          bomFormat: "CycloneDX",
          specVersion: "1.5",
          version: 1,
          components: [],
        }, null, 2));
      }
    }
    
    if (!fs.existsSync(outputPath)) {
      this.logger.log('SBOM generation was unsuccessful');
    }

    this.logger.log('SBOM generation successful');
    return fs.readFileSync(outputPath, 'utf-8');
  }


  getWatchMetadataSbom(sbom: string) {
    
    const sbomJson = JSON.parse(sbom);

    const components = sbomJson.components || [];

    // Summaries
    const totalComponents = components.length;
    const licenseSummary: Record<string, number> = {};
    const riskSummary: Record<string, number> = { Low: 0, Medium: 0, High: 0, Unknown: 0 };

    const sbomPackage = sbomJson.metadata.component["bom-ref"];
    const rootDep = (sbomJson.dependencies || []).find(
      (dep: any) => dep.ref === sbomPackage
    );

    const directDependencies = rootDep?.dependsOn?.length || 0;
    const transitiveDependencies = totalComponents - directDependencies;

    

    // License risk mapping
    const licenseRisk: Record<string, string> = {
      'MIT': 'Low',
      'Apache-2.0': 'Low',
      'BSD-2-Clause': 'Low',
      'BSD-3-Clause': 'Low',
      'ISC': 'Low',
      '0BSD': 'Low',
      'MPL-2.0': 'Medium',
      'LGPL-2.1': 'Medium',
      'LGPL-3.0': 'Medium',
      'GPL-2.0': 'High',
      'GPL-3.0': 'High',
      'AGPL-3.0': 'High',
    };

    // Loop over components
    for (const comp of components) {
      // Count licenses
      const licenseId = comp?.licenses?.[0]?.license?.id || 'Unknown';
      licenseSummary[licenseId] = (licenseSummary[licenseId] || 0) + 1;

      // Risk bucket
      const riskLevel = licenseRisk[licenseId] || 'Unknown';
      riskSummary[riskLevel]++;

      // Count direct vs transitive (dependsOn usually marks direct vs transitive)
      // In CycloneDX: If it appears in dependencies root list, consider direct
    }
    return {
      sbomPackage,
      directDependencies,
      transitiveDependencies,
      licenseSummary,
      riskSummary,
    };

  }

  getNodeDeps(sbomText: string, node_id: string, vulnerablePackages: string[]) {
    const sbomJson = JSON.parse(sbomText);

    const depMap = new Map<string, string[]>(
    sbomJson.dependencies.map((d: any) => [d.ref, d.dependsOn || []])
  );

  // Get the main node
  const node = sbomJson.dependencies.find((c: any) => c.ref === node_id);
  if (!node) return { nodes: [], links: [] };

  const directDeps = node.dependsOn || [];

  // Recursive check for vulnerability
  const isNodeVulnerable = (pkgId: string, seen = new Set<string>()): boolean => {
    if (seen.has(pkgId)) return false;
    seen.add(pkgId);

    // Directly vulnerable
    if (vulnerablePackages.includes(pkgId)) return true;

    // Recurse into dependencies
    const deps = depMap.get(pkgId) || [];
    return deps.some((dep) => isNodeVulnerable(dep, seen));
  };

  // Build nodes: main node + direct dependencies only
  const nodes = [{ id: node.ref, color: "lightblue" }];
  const links: { source: string; target: string }[] = [];

  for (const dep of directDeps) {
    const isVuln = isNodeVulnerable(dep);
    nodes.push({ id: dep, color: isVuln ? "red" : "lightblue" });
    links.push({ source: node.ref, target: dep });
  }

  return { nodes, links };
  }

  searchNodeDeps(sbomText: string, search: string) {
    const sbomJson = JSON.parse(sbomText);

    // 2. Normalize search (lowercase for case-insensitive match)
    const searchLower = search.toLowerCase();
    // 3. Filter dependencies whose ref or name contains the search string
    const matchedNodes = sbomJson.dependencies.filter((node: any) => {
      const ref = node.ref?.toLowerCase() || "";
      const name = node.name?.toLowerCase() || "";
      return ref.includes(searchLower) || name.includes(searchLower);
    });

    // 4. Optionally, you can return dependencies of matched nodes or just the nodes
    // For now, return matched nodes with their dependsOn arrays

    return matchedNodes.map((node: any) => ({
      node: {
        id: node.ref,
        name: node.name,
        dependsOn: node.dependsOn || [],
      },
    }));

  }

  async getDepList(user_id: string) {
    return await this.sbomRepo.getWatchFollows(user_id);
  }

  private async cleanupTempFolder(repoPath: string) {
    try {
      await fs.promises.rm(repoPath, { recursive: true, force: true });
      this.logger.log(`‚úÖ Cleaned up temporary folder: ${path}`);
    } catch (err) {
      this.logger.error(`‚ö†Ô∏è Failed to clean up temp folder: ${err.message}`);
    }
  }

  private parseSbom(data: string) {
    this.logger.log('Parsing SBOM JSON data');
    return JSON.parse(data);
  }

  async addSbom(watchlistId: string) {
    const gitUrl = ( await this.sbomRepo.getUrl(watchlistId) )?.repo_url;
    const repoPath = await this.cloneRepo(gitUrl!);
    this.cleanupRepo(repoPath);
    const data = await this.genSbom(repoPath);
    const jsonData = await this.parseSbom(data);
    const createSbomDto: CreateSbomDto = {
      id: watchlistId, 
      sbom: jsonData
    }
    this.sbomRepo.upsertWatchSbom(createSbomDto);
    this.cleanupTempFolder(repoPath);
    
    return jsonData;
  }

  async writeSbomsToTempFiles(sboms: Array<{ sbom: any }>) {
    const tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'sbom-'));
    const filePaths: string[] = [];

    for (let i = 0; i < sboms.length; i++) {
      const filePath = path.join(tempDir, `sbom_${i}.json`);
      await fs.promises.writeFile(filePath, JSON.stringify(sboms[i].sbom, null, 2), 'utf8');
      filePaths.push(filePath);
    }

    return { tempDir, filePaths };
  }

  async mergeSbom(user_id: string) {
    const sboms = await this.sbomRepo.getFollowSboms(user_id);
    const {tempDir, filePaths} = await this.writeSbomsToTempFiles(sboms);
    
    const absPath = tempDir;
    const containerPath = '/app';
    const filenames = filePaths.map(f => path.basename(f));

    await this.runCommand({
      image: 'cyclonedx-cli',
      cmd: [
        'merge',
        '--input-files',
        ...filenames.map(name => `${containerPath}/${name}`),
        '--output-file', `merged.json`],
      workingDir: containerPath,
      volumeHostPath: absPath,
    });

    const mergedPath = path.join(absPath, 'merged.json');
    const mergedString = await fs.promises.readFile(mergedPath, 'utf-8');
    const mergedData = JSON.parse(mergedString);


    const originalTopComponents = sboms
    .map((sbom) => {
      try {
        const parsed = JSON.parse(JSON.stringify(sbom.sbom));
        return parsed.metadata?.component?.['bom-ref'];
      } catch (e) {
        return null;
      }
    })
    .filter(Boolean);

    const newTop = {
      type: "application",
      "bom-ref": `pkg:user/${user_id}@latest`,
      name: `user-watchlist-sbom-${user_id}`,
      version: "1.0.0"
    };

    mergedData.metadata = {
    ...(mergedData.metadata || {}),
    component: newTop
  };

    mergedData.dependencies = [
    {
      ref: newTop["bom-ref"],
      dependsOn: originalTopComponents
    },
    ...(mergedData.dependencies || [])
  ];


    
    // Clean up
    await this.cleanupTempFolder(tempDir);

    const createSbomDto: CreateSbomDto = {
      id: user_id, 
      sbom: mergedData
    }

    this.sbomRepo.upsertUserSbom(createSbomDto);


    return await mergedData;

  }


}
