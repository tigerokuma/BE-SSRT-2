name: 🚀 Deploy to GCP Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:  # Allow manual triggers

env:
  NODE_VERSION: '20'
  APP_NAME: 'nestjs-api'
  DEPLOY_PATH: '~/BE-SSRT-2/ossrepo-backend'

jobs:
  validate:
    name: 🔍 Code Validation
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ossrepo-backend
    
    steps:
    - name: 📥 Checkout Repository
      uses: actions/checkout@v4
      
    - name: ⚙️ Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: ossrepo-backend/package-lock.json
    
    - name: 📦 Install Dependencies
      run: |
        echo "::group::📦 Installing NPM packages"
        npm ci --only=production
        echo "::endgroup::"
    
    - name: 🔧 Generate Prisma Client
      run: |
        echo "::group::🔧 Generating Prisma client"
        npx prisma generate --schema=prisma/schema.prisma
        echo "✅ Prisma client generated successfully"
        echo "::endgroup::"
    
    - name: 🏗️ Build Application
      run: |
        echo "::group::🏗️ Building NestJS application"
        npm run build
        echo "✅ Application built successfully"
        echo "::endgroup::"
    
    - name: 🧪 Run Tests (if available)
      run: |
        if [ -f "package.json" ] && grep -q '"test"' package.json; then
          echo "::group::🧪 Running tests"
          npm test || echo "::warning::Tests failed but continuing deployment"
          echo "::endgroup::"
        else
          echo "::notice::No tests found, skipping test step"
        fi
      continue-on-error: true

  deploy:
    name: 🚀 Production Deployment
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    
    steps:
    - name: 📥 Checkout Repository
      uses: actions/checkout@v4
    
    - name: 🚀 Deploy to GCP Server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT || '22' }}
        timeout: 300s
        command_timeout: 120s
        script_stop: true
        script: |
          # Color codes for beautiful logging
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          PURPLE='\033[0;35m'
          CYAN='\033[0;36m'
          WHITE='\033[1;37m'
          NC='\033[0m' # No Color
          
          # Logging functions
          log_info() { echo -e "${BLUE}ℹ️  INFO${NC}: $1"; }
          log_success() { echo -e "${GREEN}✅ SUCCESS${NC}: $1"; }
          log_warning() { echo -e "${YELLOW}⚠️  WARNING${NC}: $1"; }
          log_error() { echo -e "${RED}❌ ERROR${NC}: $1"; }
          log_step() { echo -e "\n${PURPLE}🔄 STEP${NC}: ${WHITE}$1${NC}"; }
          log_header() { echo -e "\n${CYAN}═══════════════════════════════════════${NC}"; echo -e "${CYAN}🚀 $1${NC}"; echo -e "${CYAN}═══════════════════════════════════════${NC}"; }
          
          # Start deployment
          log_header "PRODUCTION DEPLOYMENT STARTED"
          log_info "Deployment started at $(date '+%Y-%m-%d %H:%M:%S UTC')"
          log_info "Target: ${{ secrets.HOST }}"
          log_info "Application: ${{ env.APP_NAME }}"
          
          # Step 1: Navigate to project directory
          log_step "Navigating to project directory"
          cd ${{ env.DEPLOY_PATH }} || {
            log_error "Failed to navigate to ${{ env.DEPLOY_PATH }}"
            exit 1
          }
          log_success "Current directory: $(pwd)"
          
          # Step 2: Backup current version
          log_step "Creating backup of current deployment"
          BACKUP_DIR="backups/$(date +%Y%m%d_%H%M%S)"
          mkdir -p "$BACKUP_DIR"
          cp -r dist "$BACKUP_DIR/" 2>/dev/null || log_warning "No dist directory to backup"
          log_success "Backup created at $BACKUP_DIR"
          
          # Step 3: Configure Git for safe operations
          log_step "Configuring Git for deployment"
          git config pull.rebase false
          git config --global --add safe.directory $(pwd)
          log_success "Git configuration updated"
          
          # Step 4: Fetch and update code
          log_step "Updating source code from repository"
          log_info "Current branch: $(git branch --show-current)"
          log_info "Current commit: $(git rev-parse --short HEAD)"
          
          git fetch origin main || {
            log_error "Failed to fetch from origin"
            exit 1
          }
          
          # Check for changes
          LOCAL_COMMIT=$(git rev-parse HEAD)
          REMOTE_COMMIT=$(git rev-parse origin/main)
          
          if [ "$LOCAL_COMMIT" = "$REMOTE_COMMIT" ]; then
            log_warning "No new changes detected, but continuing deployment"
          else
            log_info "New changes detected, updating codebase"
            git reset --hard origin/main || {
              log_error "Failed to reset to origin/main"
              exit 1
            }
          fi
          
          log_success "Code updated to commit: $(git rev-parse --short HEAD)"
          
          # Step 5: Check Node.js version
          log_step "Verifying runtime environment"
          NODE_VERSION=$(node --version)
          log_info "Node.js version: $NODE_VERSION"
          
          if [[ ! "$NODE_VERSION" =~ ^v(20|21|22) ]]; then
            log_warning "Node.js version $NODE_VERSION may not be optimal (recommended: v20+)"
          else
            log_success "Node.js version is compatible"
          fi
          
          # Step 6: Install dependencies
          log_step "Installing application dependencies"
          log_info "Installing NPM packages..."
          npm ci --only=production --silent || {
            log_error "Failed to install dependencies"
            exit 1
          }
          log_success "Dependencies installed successfully"
          
          # Step 7: Generate Prisma client
          log_step "Generating Prisma database client"
          npx prisma generate --schema=prisma/schema.prisma || {
            log_error "Failed to generate Prisma client"
            exit 1
          }
          log_success "Prisma client generated successfully"
          
          # Step 8: Apply database migrations
          log_step "Applying database migrations"
          log_info "Checking for pending migrations..."
          npx prisma migrate deploy --schema=prisma/schema.prisma || {
            log_error "Failed to apply database migrations"
            exit 1
          }
          log_success "Database migrations applied successfully"
          
          # Step 9: Build application
          log_step "Building application for production"
          log_info "Starting build process..."
          npm run build || {
            log_error "Failed to build application"
            exit 1
          }
          log_success "Application built successfully"
          
          # Step 10: Health check before restart
          log_step "Performing pre-restart health check"
          if pm2 describe ${{ env.APP_NAME }} > /dev/null 2>&1; then
            log_info "Application is currently running"
            CURRENT_UPTIME=$(pm2 describe ${{ env.APP_NAME }} | grep uptime | awk '{print $4}')
            log_info "Current uptime: $CURRENT_UPTIME"
          else
            log_warning "Application is not currently running"
          fi
          
          # Step 11: Restart application
          log_step "Restarting application service"
          pm2 restart ${{ env.APP_NAME }} || {
            log_error "Failed to restart application"
            log_info "Attempting to start application..."
            pm2 start ecosystem.config.js || pm2 start dist/main.js --name ${{ env.APP_NAME }} || {
              log_error "Failed to start application"
              exit 1
            }
          }
          
          # Step 12: Post-deployment health check
          log_step "Performing post-deployment health check"
          sleep 5
          
          if pm2 describe ${{ env.APP_NAME }} | grep -q "online"; then
            log_success "Application is running and healthy"
            
            # Show application status
            log_info "Application Status:"
            pm2 describe ${{ env.APP_NAME }} | grep -E "(status|uptime|cpu|memory)" || true
            
            # Test API endpoint if available
            if command -v curl > /dev/null 2>&1; then
              log_info "Testing API health endpoint..."
              if curl -f -s http://localhost:3000/health > /dev/null 2>&1; then
                log_success "API health check passed"
              else
                log_warning "API health check failed or endpoint not available"
              fi
            fi
          else
            log_error "Application failed to start properly"
            pm2 logs ${{ env.APP_NAME }} --lines 10
            exit 1
          fi
          
          # Step 13: Cleanup old backups (keep last 5)
          log_step "Cleaning up old backups"
          if [ -d "backups" ]; then
            cd backups
            ls -t | tail -n +6 | xargs -r rm -rf
            BACKUP_COUNT=$(ls -1 | wc -l)
            log_success "Cleanup completed, $BACKUP_COUNT backups retained"
            cd ..
          fi
          
          # Deployment summary
          log_header "DEPLOYMENT COMPLETED SUCCESSFULLY"
          log_success "Deployment finished at $(date '+%Y-%m-%d %H:%M:%S UTC')"
          log_success "Application: ${{ env.APP_NAME }}"
          log_success "Commit: $(git rev-parse --short HEAD)"
          log_success "Build: $(date +%Y%m%d_%H%M%S)"
          log_info "🎉 Your application is now live and running!"
          
          echo -e "\n${GREEN}══════════════════════════════════════════════════════════${NC}"
          echo -e "${GREEN}🚀 PRODUCTION DEPLOYMENT SUCCESSFUL 🚀${NC}"
          echo -e "${GREEN}══════════════════════════════════════════════════════════${NC}\n"

  notify:
    name: 📢 Deployment Notification
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()
    
    steps:
    - name: 📢 Notify Deployment Status
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "✅ Deployment completed successfully!"
          echo "🚀 Application is now live on production"
        else
          echo "❌ Deployment failed!"
          echo "🔧 Please check the logs and fix any issues"
          exit 1
        fi
