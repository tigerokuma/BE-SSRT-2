import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { ConfigService } from '@nestjs/config';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  cveId?: string;
  ghsaId?: string;
  publishedDate: string;
  affectedVersions: string[];
  fixedVersions?: string[];
  references: Array<{
    url: string;
    type: string;
  }>;
}

export interface VulnerabilitySummary {
  totalCount: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  lastUpdated: string;
}

@Injectable()
export class VulnerabilityService {
  private readonly logger = new Logger(VulnerabilityService.name);

  constructor(
    private readonly httpService: HttpService,
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {}

  async fetchVulnerabilities(
    packageName: string,
    repoUrl?: string,
  ): Promise<Vulnerability[]> {
    try {
      if (repoUrl && repoUrl.includes('github.com')) {
        this.logger.log(
          `Fetching vulnerabilities from GitHub Security Advisories for: ${repoUrl}`,
        );
        const githubVulnerabilities = await this.fetchFromGitHub(repoUrl);

        if (githubVulnerabilities.length > 0) {
          this.logger.log(
            `Found ${githubVulnerabilities.length} vulnerabilities from GitHub Security Advisories`,
          );
          return githubVulnerabilities;
        }
      }

      this.logger.log(
        `No GitHub repository URL provided or no vulnerabilities found`,
      );
      return [];
    } catch (error) {
      this.logger.error(
        `Failed to fetch vulnerabilities for package ${packageName}:`,
        error,
      );
      return [];
    }
  }

  private async fetchFromGitHub(repoUrl: string): Promise<Vulnerability[]> {
    try {
      const urlMatch = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
      if (!urlMatch) {
        this.logger.warn(`Could not parse GitHub URL: ${repoUrl}`);
        return [];
      }

      const [, owner, repo] = urlMatch;
      this.logger.log(
        `Fetching GitHub Security Advisories for ${owner}/${repo}`,
      );

      const githubToken = this.configService.get<string>('GITHUB_TOKEN');
      if (!githubToken) {
        this.logger.warn('GitHub token not found in environment variables');
      }

      const headers: any = {
        Accept: 'application/vnd.github.security-events-preview+json',
        'X-GitHub-Api-Version': '2022-11-28',
      };

      if (githubToken) {
        headers['Authorization'] = `Bearer ${githubToken}`;
      }

      const response = await firstValueFrom(
        this.httpService.get(
          `https://api.github.com/repos/${owner}/${repo}/security-advisories`,
          {
            headers,
          },
        ),
      );

      this.logger.log(
        `GitHub API response status: ${response.status}, data length: ${response.data?.length || 0}`,
      );

      const vulnerabilities: Vulnerability[] = [];

      if (response.data && response.data.length > 0) {
        this.logger.log(
          `Found ${response.data.length} GitHub Security Advisories`,
        );

        for (const advisory of response.data) {
          const vulnerability: Vulnerability = {
            id: advisory.ghsa_id,
            title: advisory.summary || 'No title available',
            description: advisory.description || 'No description available',
            severity: this.mapGitHubSeverity(advisory.severity),
            cveId: advisory.cve_id,
            ghsaId: advisory.ghsa_id,
            publishedDate: advisory.published_at || new Date().toISOString(),
            affectedVersions:
              advisory.vulnerabilities?.map(
                (v) => v.vulnerable_version_range,
              ) || [],
            fixedVersions:
              advisory.vulnerabilities?.map((v) => v.patched_versions) || [],
            references: [
              {
                url: advisory.html_url,
                type: 'GitHub Advisory',
              },
              ...(advisory.references?.map((ref) => ({
                url: ref.url,
                type: ref.type || 'UNKNOWN',
              })) || []),
            ],
          };

          vulnerabilities.push(vulnerability);
        }

        this.logger.log(
          `Returning ${vulnerabilities.length} GitHub advisories`,
        );
      } else {
        this.logger.log(
          `No GitHub Security Advisories found for ${owner}/${repo}`,
        );
      }

      return vulnerabilities;
    } catch (error) {
      this.logger.warn(
        `Failed to fetch GitHub Security Advisories:`,
        error.message,
      );
      if (error.response) {
        this.logger.warn(
          `GitHub API error status: ${error.response.status}, data: ${JSON.stringify(error.response.data)}`,
        );
      }
      return [];
    }
  }

  private mapGitHubSeverity(
    githubSeverity: string,
  ): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    switch (githubSeverity?.toLowerCase()) {
      case 'critical':
        return 'CRITICAL';
      case 'high':
        return 'HIGH';
      case 'medium':
        return 'MEDIUM';
      case 'low':
        return 'LOW';
      default:
        return 'MEDIUM';
    }
  }

  generateVulnerabilitySummary(
    vulnerabilities: Vulnerability[],
  ): VulnerabilitySummary {
    const summary: VulnerabilitySummary = {
      totalCount: vulnerabilities.length,
      criticalCount: vulnerabilities.filter((v) => v.severity === 'CRITICAL')
        .length,
      highCount: vulnerabilities.filter((v) => v.severity === 'HIGH').length,
      mediumCount: vulnerabilities.filter((v) => v.severity === 'MEDIUM')
        .length,
      lowCount: vulnerabilities.filter((v) => v.severity === 'LOW').length,
      lastUpdated: new Date().toISOString(),
    };

    return summary;
  }

  async storeVulnerabilities(
    watchlistId: string,
    vulnerabilities: Vulnerability[],
    summary: VulnerabilitySummary,
  ): Promise<void> {
    try {
      await this.prisma.vulnerabilitySummary.upsert({
        where: { watchlist_id: watchlistId },
        update: {
          total_count: summary.totalCount,
          critical_count: summary.criticalCount,
          high_count: summary.highCount,
          medium_count: summary.mediumCount,
          low_count: summary.lowCount,
          last_updated: new Date(),
        },
        create: {
          watchlist_id: watchlistId,
          total_count: summary.totalCount,
          critical_count: summary.criticalCount,
          high_count: summary.highCount,
          medium_count: summary.mediumCount,
          low_count: summary.lowCount,
        },
      });

      await this.prisma.vulnerability.deleteMany({
        where: { watchlist_id: watchlistId },
      });

      if (vulnerabilities.length > 0) {
        await this.prisma.vulnerability.createMany({
          data: vulnerabilities.map((vuln) => ({
            watchlist_id: watchlistId,
            title: vuln.title,
            description: vuln.description,
            severity: vuln.severity,
            cve_id: vuln.cveId,
            ghsa_id: vuln.ghsaId,
            published_date: new Date(vuln.publishedDate),
            affected_versions: vuln.affectedVersions,
            fixed_versions: vuln.fixedVersions,
            references: vuln.references,
          })),
        });
      }

      this.logger.log(
        `Stored ${vulnerabilities.length} vulnerabilities for watchlist ${watchlistId}`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to store vulnerabilities for watchlist ${watchlistId}:`,
        error,
      );
      throw error;
    }
  }

  async getVulnerabilities(watchlistId: string): Promise<{
    vulnerabilities: Vulnerability[];
    summary: VulnerabilitySummary;
  } | null> {
    try {
      const summary = await this.prisma.vulnerabilitySummary.findUnique({
        where: { watchlist_id: watchlistId },
      });

      const vulnerabilities = await this.prisma.vulnerability.findMany({
        where: { watchlist_id: watchlistId },
        orderBy: { published_date: 'desc' },
      });

      if (!summary) {
        return null;
      }

      return {
        vulnerabilities: vulnerabilities.map((vuln) => ({
          id: vuln.id,
          title: vuln.title,
          description: vuln.description,
          severity: vuln.severity as 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
          cveId: vuln.cve_id || undefined,
          ghsaId: vuln.ghsa_id || undefined,
          publishedDate: vuln.published_date.toISOString(),
          affectedVersions: vuln.affected_versions,
          fixedVersions: vuln.fixed_versions,
          references: vuln.references as Array<{ url: string; type: string }>,
        })),
        summary: {
          totalCount: summary.total_count,
          criticalCount: summary.critical_count,
          highCount: summary.high_count,
          mediumCount: summary.medium_count,
          lowCount: summary.low_count,
          lastUpdated: summary.last_updated.toISOString(),
        },
      };
    } catch (error) {
      this.logger.error(
        `Failed to retrieve vulnerabilities for watchlist ${watchlistId}:`,
        error,
      );
      return null;
    }
  }
}
