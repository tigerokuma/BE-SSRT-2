import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { VulnerabilityService } from '../services/vulnerability.service';
import { AlertingService } from '../services/alerting.service';

interface VulnerabilityCheckJobData {
  watchlistId?: string; // Optional: if provided, check only this repository
}

@Processor('vulnerability-check')
export class VulnerabilityCheckProcessor {
  private readonly logger = new Logger(VulnerabilityCheckProcessor.name);
  private isProcessingWeeklyCheck = false; // Prevent concurrent weekly checks

  constructor(
    private readonly prisma: PrismaService,
    private readonly vulnerabilityService: VulnerabilityService,
    private readonly alertingService: AlertingService,
    @InjectQueue('vulnerability-check') private readonly vulnerabilityQueue: Queue,
  ) {
    // Removed automatic vulnerability check initialization to prevent duplicate jobs on server restart
    // Vulnerability checking should be manually triggered or scheduled externally
  }

  /**
   * Initialize the weekly vulnerability check schedule (call this to make the queue visible in BullMQ)
   */
  async initializeVulnerabilityCheckSchedule() {
    this.logger.log('🚀 Initializing vulnerability check schedule...');
    
    try {
      // First, add an immediate job to make the queue visible
      await this.vulnerabilityQueue.add(
        'weekly-vulnerability-check',
        {},
        {
          attempts: 1,
          removeOnComplete: 10,
          removeOnFail: 50,
        },
      );
      
      this.logger.log('✅ Added immediate vulnerability check job to make queue visible');
      
      // Then schedule the next weekly check
      await this.initializeWeeklyVulnerabilityCheck();
    } catch (error) {
      this.logger.error('Error initializing vulnerability check schedule:', error);
      throw error;
    }
  }

  /**
   * Weekly job that checks all repositories for new critical vulnerabilities
   */
  async triggerWeeklyVulnerabilityCheck() {
    // Prevent concurrent weekly checks
    if (this.isProcessingWeeklyCheck) {
      this.logger.log('⏳ Weekly vulnerability check already in progress, skipping...');
      return;
    }

    this.isProcessingWeeklyCheck = true;

    this.logger.log(
      `\n────────────────────────────────────────────────────────────\n🔍 WEEKLY VULNERABILITY CHECK TRIGGERED\n────────────────────────────────────────────────────────────`
    );

    try {
      // Get all ready repositories from watchlist
      const watchlistedRepos = await this.prisma.watchlist.findMany({
        where: {
          status: 'ready',
        },
        select: {
          watchlist_id: true,
          package: {
            select: {
              repo_url: true,
              repo_name: true,
              package_name: true,
            }
          },
        },
      });

      this.logger.log(`Found ${watchlistedRepos.length} ready repositories to check for vulnerabilities`);

      // Process repositories sequentially
      let processedCount = 0;
      let newCriticalVulnerabilitiesFound = 0;

      for (const repo of watchlistedRepos) {
        const { repo_url, repo_name, package_name } = repo.package;
        
        if (!repo_url) {
          this.logger.warn(`No repo URL found for ${repo_name}, skipping`);
          continue;
        }

        try {
          const newVulnerabilities = await this.checkRepositoryVulnerabilities(
            repo.watchlist_id,
            package_name,
            repo_url,
            repo_name
          );
          
          if (newVulnerabilities > 0) {
            newCriticalVulnerabilitiesFound += newVulnerabilities;
          }
          
          processedCount++;
          
          // Small delay between repositories to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
          this.logger.error(`Error checking vulnerabilities for ${repo_name}:`, error);
          // Continue with next repository instead of failing entire process
        }
      }

      this.logger.log(`✅ Completed vulnerability check for ${processedCount}/${watchlistedRepos.length} repositories`);
      this.logger.log(`🚨 Found ${newCriticalVulnerabilitiesFound} new critical vulnerabilities across all repositories`);

      // Schedule the next weekly vulnerability check for next week
      await this.scheduleNextWeeklyVulnerabilityCheck();
    } catch (error) {
      this.logger.error('Error during weekly vulnerability check trigger:', error);
    } finally {
      this.isProcessingWeeklyCheck = false;
    }
  }

  /**
   * Check vulnerabilities for a single repository
   */
  private async checkRepositoryVulnerabilities(
    watchlistId: string,
    packageName: string,
    repoUrl: string,
    repoName: string
  ): Promise<number> {
    try {
      this.logger.log(`🔍 Checking vulnerabilities for ${repoName} (${packageName})`);

      // Get current vulnerabilities from database
      const currentVulnerabilities = await this.vulnerabilityService.getVulnerabilities(watchlistId);
      const currentCriticalCount = currentVulnerabilities?.summary.criticalCount || 0;

      // Fetch latest vulnerabilities from GitHub API
      const newVulnerabilities = await this.vulnerabilityService.fetchVulnerabilities(packageName, repoUrl);
      
      if (newVulnerabilities.length === 0) {
        this.logger.log(`✅ No vulnerabilities found for ${repoName}`);
        return 0;
      }

      // Generate summary
      const summary = this.vulnerabilityService.generateVulnerabilitySummary(newVulnerabilities);

      // Store new vulnerabilities in database
      await this.vulnerabilityService.storeVulnerabilities(watchlistId, newVulnerabilities, summary);

      // Check if there are new critical vulnerabilities
      const newCriticalCount = summary.criticalCount;
      const newCriticalVulnerabilities = newCriticalCount - currentCriticalCount;

      if (newCriticalVulnerabilities > 0) {
        this.logger.log(`🚨 Found ${newCriticalVulnerabilities} new critical vulnerabilities for ${repoName}`);
        
        // Create alerts for new critical vulnerabilities
        await this.createVulnerabilityAlerts(watchlistId, newVulnerabilities, repoName);
        
        return newCriticalVulnerabilities;
      } else {
        this.logger.log(`✅ No new critical vulnerabilities found for ${repoName}`);
        return 0;
      }
    } catch (error) {
      this.logger.error(`Error checking vulnerabilities for ${repoName}:`, error);
      return 0;
    }
  }

  /**
   * Create alerts for new critical vulnerabilities
   */
  private async createVulnerabilityAlerts(
    watchlistId: string,
    vulnerabilities: any[],
    repoName: string
  ): Promise<void> {
    try {
      // Get all users watching this repository
      const userWatchlists = await this.prisma.userWatchlist.findMany({
        where: { watchlist_id: watchlistId },
        select: {
          id: true,
          user_id: true,
        },
      });

      if (userWatchlists.length === 0) {
        this.logger.log(`No users watching repository ${watchlistId}`);
        return;
      }

      // Filter for critical vulnerabilities
      const criticalVulnerabilities = vulnerabilities.filter(v => v.severity === 'CRITICAL');

      for (const vulnerability of criticalVulnerabilities) {
        for (const userWatchlist of userWatchlists) {
          await this.createVulnerabilityAlert(
            userWatchlist.id,
            watchlistId,
            vulnerability,
            repoName
          );
        }
      }
    } catch (error) {
      this.logger.error(`Error creating vulnerability alerts for ${repoName}:`, error);
    }
  }

  /**
   * Create a single vulnerability alert
   */
  private async createVulnerabilityAlert(
    userWatchlistId: string,
    watchlistId: string,
    vulnerability: any,
    repoName: string
  ): Promise<void> {
    try {
      const details = {
        vulnerability: {
          id: vulnerability.id,
          title: vulnerability.title,
          description: vulnerability.description,
          severity: vulnerability.severity,
          cveId: vulnerability.cveId,
          ghsaId: vulnerability.ghsaId,
          publishedDate: vulnerability.publishedDate,
          affectedVersions: vulnerability.affectedVersions,
          fixedVersions: vulnerability.fixedVersions,
          references: vulnerability.references,
        },
        repository: {
          name: repoName,
          watchlistId: watchlistId,
        },
      };

      await this.prisma.alertTriggered.create({
        data: {
          user_watchlist_id: userWatchlistId,
          watchlist_id: watchlistId,
          commit_sha: 'vulnerability-check', // Special identifier for vulnerability alerts
          contributor: 'security-system',
          metric: 'critical_vulnerability_detected',
          value: 1, // Always 1 for vulnerability detection
          alert_level: 'critical',
          threshold_type: 'vulnerability_check',
          threshold_value: 0,
          description: `Critical vulnerability detected in ${repoName}: ${vulnerability.title}`,
          details_json: details,
        },
      });

      this.logger.log(
        `🚨 VULNERABILITY ALERT CREATED: ${vulnerability.title} - ${repoName}`,
      );
    } catch (error) {
      this.logger.error(`Error creating vulnerability alert:`, error);
    }
  }

  /**
   * Schedule the next weekly vulnerability check
   */
  private async scheduleNextWeeklyVulnerabilityCheck(): Promise<void> {
    try {
      // Check if there's already a weekly vulnerability check job scheduled
      const waitingJobs = await this.vulnerabilityQueue.getWaiting();
      const existingWeeklyCheckJob = waitingJobs.find(job => job.name === 'weekly-vulnerability-check');
      
      if (existingWeeklyCheckJob) {
        this.logger.log('📅 Weekly vulnerability check job already scheduled, skipping duplicate');
        return;
      }

      // Calculate delay until next week (7 days from now)
      const now = new Date();
      const nextWeek = new Date(now);
      nextWeek.setDate(nextWeek.getDate() + 7);
      nextWeek.setHours(0, 0, 0, 0); // Set to midnight
      
      const delayMs = nextWeek.getTime() - now.getTime();
      
      await this.vulnerabilityQueue.add(
        'weekly-vulnerability-check',
        {},
        {
          delay: delayMs,
          attempts: 1, // Don't retry weekly vulnerability check if it fails
          removeOnComplete: 10,
          removeOnFail: 50,
        },
      );

      this.logger.log(`📅 Scheduled next weekly vulnerability check for ${nextWeek.toISOString()}`);
    } catch (error) {
      this.logger.error('Error scheduling next weekly vulnerability check:', error);
    }
  }

  /**
   * Initialize weekly vulnerability checking schedule
   */
  private async initializeWeeklyVulnerabilityCheck(): Promise<void> {
    try {
      // Check if there's already a weekly vulnerability check job scheduled
      const waitingJobs = await this.vulnerabilityQueue.getWaiting();
      const weeklyCheckJob = waitingJobs.find(job => job.name === 'weekly-vulnerability-check');
      
      if (!weeklyCheckJob) {
        this.logger.log('🚀 Initializing weekly vulnerability check schedule...');
        await this.scheduleNextWeeklyVulnerabilityCheck();
      } else {
        this.logger.log('📅 Weekly vulnerability check schedule already exists');
      }
    } catch (error) {
      this.logger.error('Error initializing weekly vulnerability check:', error);
    }
  }

  @Process('weekly-vulnerability-check')
  async handleWeeklyVulnerabilityCheck(job: Job) {
    this.logger.log('🕛 Weekly vulnerability check job triggered');
    await this.triggerWeeklyVulnerabilityCheck();
  }

  @Process('check-single-repository')
  async handleSingleRepositoryCheck(job: Job<VulnerabilityCheckJobData>) {
    const { watchlistId } = job.data;
    
    if (!watchlistId) {
      this.logger.error('No watchlistId provided for single repository vulnerability check');
      return;
    }

    this.logger.log(`🔍 Single repository vulnerability check triggered for ${watchlistId}`);

    try {
      const watchlist = await this.prisma.watchlist.findUnique({
        where: { watchlist_id: watchlistId },
        include: {
          package: {
            select: {
              repo_url: true,
              repo_name: true,
              package_name: true,
            }
          }
        }
      });

      if (!watchlist || !watchlist.package) {
        this.logger.error(`No package found for watchlist ${watchlistId}`);
        return;
      }

      const { repo_url, repo_name, package_name } = watchlist.package;
      
      if (!repo_url) {
        this.logger.error(`No repo URL found for watchlist ${watchlistId}`);
        return;
      }

      await this.checkRepositoryVulnerabilities(watchlistId, package_name, repo_url, repo_name);
    } catch (error) {
      this.logger.error(`Error in single repository vulnerability check for ${watchlistId}:`, error);
    }
  }
}
