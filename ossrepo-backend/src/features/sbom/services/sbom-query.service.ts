import { Injectable, Logger, Body } from '@nestjs/common';
import { SbomRepository } from '../repositories/sbom.repository';
import { simpleGit } from 'simple-git';
import { randomUUID } from 'crypto';
import * as path from 'path';
import * as os from 'os';




@Injectable()
export class SbomQueryService {

  private readonly logger = new Logger(SbomQueryService.name);

  constructor(private readonly sbomRepo: SbomRepository) {}

  // Fetch SBOM tied to the watchlist for a user
  async getWatchSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getWatchSbom(user_id);
    return sbomData;
  }

  // Fetch personal SBOM generated by user
  async getUserSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getUserSbom(user_id);
    return sbomData;
  }

  // Clone Git repo into a temp directory
  async cloneRepo(gitUrl: string): Promise<string> {
    const targetDir = path.join(os.tmpdir(), 'sbom-repos');
    const uniqueDir = path.join(targetDir, randomUUID());

    const clonePath = path.resolve(uniqueDir);
    const git = simpleGit();

    try {
      console.log(`Cloning ${gitUrl} into ${clonePath}...`);
      await git.clone(gitUrl, clonePath);
      console.log('Clone complete.');
    } catch (err) {
      console.error('Error cloning repo:', err);
      throw err;
    }
    return uniqueDir;
  }

  // Generate summary stats for the selected sbom
  getWatchMetadataSbom(sbom: string) {
    const sbomJson = JSON.parse(sbom);
    const components = sbomJson.components || [];

    // Summaries
    const totalComponents = components.length;
    const licenseSummary: Record<string, number> = {};

    const sbomPackage = sbomJson.metadata.component["bom-ref"];
    const rootDep = (sbomJson.dependencies || []).find(
      (dep: any) => dep.ref === sbomPackage
    );

    const directDependencies = rootDep?.dependsOn?.length || 0;
    const transitiveDependencies = totalComponents - directDependencies;

    // Loop over components
    for (const comp of components) {
      // Count licenses
      const licenseId = comp?.licenses?.[0]?.license?.id || 'Unknown';
      licenseSummary[licenseId] = (licenseSummary[licenseId] || 0) + 1;

    }
    return {
      sbomPackage,
      directDependencies,
      transitiveDependencies,
      licenseSummary,
    };

  }

  // Get the dependencies that are directly linked to the node
  getNodeDeps(sbomText: string, node_id: string, vulnerablePackages: string[]) {
    const sbomJson = JSON.parse(sbomText);

    const depMap = new Map<string, string[]>(
      sbomJson.dependencies.map((d: any) => [d.ref, d.dependsOn || []])
    );

    // Get the main node
    const node = sbomJson.dependencies.find((c: any) => c.ref === node_id);
    if (!node) return { nodes: [], links: [] };

    const directDeps = node.dependsOn || [];

    // Recursive check for vulnerability
    const isNodeVulnerable = (pkgId: string, seen = new Set<string>()): boolean => {
      if (seen.has(pkgId)) return false;
      seen.add(pkgId);

      // Directly vulnerable
      if (vulnerablePackages.includes(pkgId)) return true;

      // Recurse into dependencies
      const deps = depMap.get(pkgId) || [];
      return deps.some((dep) => isNodeVulnerable(dep, seen));
    };

    // Build nodes: main node + direct dependencies only
    const nodes = [{ id: node.ref, color: "grey" }];
    const links: { source: string; target: string }[] = [];

    for (const dep of directDeps) {
      const isVuln = isNodeVulnerable(dep);
      nodes.push({ id: dep, color: isVuln ? "red" : "lightblue" });
      links.push({ source: node.ref, target: dep });
    }

    return { nodes, links };
  }

  // Search the node deps
  searchNodeDeps(sbomText: string, search: string) {
    // Parse and normalize the search
    const sbomJson = JSON.parse(sbomText);
    const searchLower = search.toLowerCase();

    // Filter dependencies whose ref or name contains the search string
    const matchedNodes = sbomJson.dependencies.filter((node: any) => {
      const ref = node.ref?.toLowerCase() || "";
      const name = node.name?.toLowerCase() || "";
      return ref.includes(searchLower) || name.includes(searchLower);
    });

    // Sort by ref
    matchedNodes.sort((a: any, b: any) =>
      (a.ref || "").localeCompare(b.ref || "", undefined, { sensitivity: "base" })
    );

    return matchedNodes.map((node: any) => ({
      node: {
        id: node.ref,
        name: node.name,
        dependsOn: node.dependsOn || [],
      },
    }));
  }

  async getDepList(user_id: string) {
    return await this.sbomRepo.getWatchFollows(user_id);
  }
}
