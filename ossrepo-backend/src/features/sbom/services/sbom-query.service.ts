import { Injectable, Logger, Body } from '@nestjs/common';
import { SbomRepository } from '../repositories/sbom.repository';



@Injectable()
export class SbomQueryService {

  private readonly logger = new Logger(SbomQueryService.name);

  constructor(private readonly sbomRepo: SbomRepository) {}

  // Fetch SBOM tied to the watchlist for a user
  async getWatchSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getWatchSbom(user_id);
    return sbomData;
  }

  // Fetch personal SBOM generated by user
  async getUserSbom(user_id: string) {
    const sbomData = await this.sbomRepo.getUserSbom(user_id);
    return sbomData;
  }

  // Generate summary stats for the selected sbom
  async getWatchMetadataSbom(sbom: string) {
    const sbomJson = JSON.parse(sbom);
    const components = sbomJson.components || [];

    // Summaries
    const totalComponents = components.length;
    const licenseSummary: Record<string, number> = {};

    const sbomPackage = sbomJson.metadata.component["bom-ref"];
    const rootDep = (sbomJson.dependencies || []).find(
      (dep: any) => dep.ref === sbomPackage
    );

    const directDependencies = rootDep?.dependsOn?.length || 0;
    const transitiveDependencies = totalComponents - directDependencies;

    // Loop over components
    for (const comp of components) {
      // Count licenses
      const licenseId = comp?.licenses?.[0]?.license?.id || 'Unknown';
      licenseSummary[licenseId] = (licenseSummary[licenseId] || 0) + 1;
    }

    // Prepare license IDs to query SPDX info
    const licenseIds = Object.keys(licenseSummary);

    // Fetch enriched license info from SPDX API
    const enrichedLicenses = await this.getLicenseInfo(licenseIds);

    // Merge counts into enriched licenses
    const licenseDetails = enrichedLicenses.map(lic => ({
        id: lic.id,
        count: licenseSummary[lic.id] || 0,
        link: lic.link,
        category: lic.category,
    }));

    return {
      sbomPackage,
      directDependencies,
      transitiveDependencies,
      licenseSummary: licenseDetails,
    };
  }

  async getLicenseInfo(licenses: string[]) {
    const spdxUrl = "https://raw.githubusercontent.com/spdx/license-list-data/main/json/licenses.json";
    const res = await fetch(spdxUrl);
    const data = await res.json();

    const results = licenses.map((id) => {
      const match = data.licenses.find((l) => l.licenseId.toLowerCase() === id.toLowerCase());
      if (!match) return { id, link: null, category: null };

      return {
        id: match.licenseId,
        link: match.seeAlso[0] || null,
        category: match.licenseCategory || (match.isOsiApproved ? "Permissive" : "Other")
      };
    });

    return results;
  }


  // Get the dependencies that are directly linked to the node
  getNodeDeps(sbomText: string, node_id: string, vulnerablePackages: string[]) {
    const sbomJson = JSON.parse(sbomText);

    const depMap = new Map<string, string[]>(
      sbomJson.dependencies.map((d: any) => [d.ref, d.dependsOn || []])
    );

    // Get the main node
    const node = sbomJson.dependencies.find((c: any) => c.ref === node_id);
    if (!node) return { nodes: [], links: [] };

    const directDeps = node.dependsOn || [];

    // Recursive check for vulnerability
    const isNodeVulnerable = (pkgId: string, seen = new Set<string>()): boolean => {
      if (seen.has(pkgId)) return false;
      seen.add(pkgId);

      // Directly vulnerable
      if (vulnerablePackages.includes(pkgId)) return true;

      // Recurse into dependencies
      const deps = depMap.get(pkgId) || [];
      return deps.some((dep) => isNodeVulnerable(dep, seen));
    };

    // Build nodes: main node + direct dependencies only
    const nodes = [{ id: node.ref, color: "grey" }];
    const links: { source: string; target: string }[] = [];

    for (const dep of directDeps) {
      const isVuln = isNodeVulnerable(dep);
      nodes.push({ id: dep, color: isVuln ? "red" : "lightblue" });
      links.push({ source: node.ref, target: dep });
    }

    return { nodes, links };
  }

  // Search the node deps
  searchNodeDeps(sbomText: string, search: string) {
    // Parse and normalize the search
    const sbomJson = JSON.parse(sbomText);
    const searchLower = search.toLowerCase();

    // Filter dependencies whose ref or name contains the search string
    const matchedNodes = sbomJson.dependencies.filter((node: any) => {
      const ref = node.ref?.toLowerCase() || "";
      const name = node.name?.toLowerCase() || "";
      return ref.includes(searchLower) || name.includes(searchLower);
    });

    // Sort by ref
    matchedNodes.sort((a: any, b: any) =>
      (a.ref || "").localeCompare(b.ref || "", undefined, { sensitivity: "base" })
    );

    return matchedNodes.map((node: any) => ({
      node: {
        id: node.ref,
        name: node.name,
        dependsOn: node.dependsOn || [],
      },
    }));
  }

  async getDepList(user_id: string) {
    return await this.sbomRepo.getWatchFollows(user_id);
  }
}
