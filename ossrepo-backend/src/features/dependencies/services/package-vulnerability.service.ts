import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../common/prisma/prisma.service';

export interface VulnerabilityCounts {
  critical: number;
  high: number;
  medium: number;
  low: number;
  total: number;
}

export interface NpmVersionInfo {
  version: string;
  releaseDate: Date;
}

@Injectable()
export class PackageVulnerabilityService {
  private readonly logger = new Logger(PackageVulnerabilityService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * Fetch package versions from NPM API
   */
  async fetchNpmVersions(packageName: string): Promise<NpmVersionInfo[]> {
    try {
      this.logger.log(`üì¶ Fetching versions for package: ${packageName}`);
      
      const response = await fetch(`https://registry.npmjs.org/${packageName}`);
      if (!response.ok) {
        throw new Error(`NPM API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const versions = data.versions || {};
      const time = data.time || {};

      const versionInfos: NpmVersionInfo[] = [];

      // Get the latest 20 versions (most recent)
      const sortedVersions = Object.keys(versions)
        .filter(version => !version.includes('-')) // Exclude pre-release versions
        .sort((a, b) => {
          // Simple version comparison (you might want to use a proper semver library)
          const aParts = a.split('.').map(Number);
          const bParts = b.split('.').map(Number);
          
          for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
            const aPart = aParts[i] || 0;
            const bPart = bParts[i] || 0;
            if (aPart !== bPart) {
              return bPart - aPart; // Descending order (newest first)
            }
          }
          return 0;
        })
        .slice(0, 20); // Get latest 20 versions

      for (const version of sortedVersions) {
        const releaseDate = time[version] ? new Date(time[version]) : new Date();
        versionInfos.push({
          version,
          releaseDate
        });
      }

      this.logger.log(`‚úÖ Found ${versionInfos.length} versions for ${packageName}`);
      return versionInfos;
    } catch (error) {
      this.logger.error(`‚ùå Failed to fetch NPM versions for ${packageName}:`, error);
      return [];
    }
  }

  /**
   * Fetch vulnerabilities from OSV API for a specific package and version
   */
  async fetchOsvVulnerabilities(packageName: string, version: string): Promise<VulnerabilityCounts> {
    try {
      this.logger.log(`üîç Checking OSV vulnerabilities for ${packageName}@${version}`);
      
      const response = await fetch('https://api.osv.dev/v1/query', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          package: {
            name: packageName,
            ecosystem: 'npm'
          },
          version: version
        })
      });

      if (!response.ok) {
        throw new Error(`OSV API returned ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const vulnerabilities = data.vulns || [];

      const counts: VulnerabilityCounts = {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        total: vulnerabilities.length
      };

      // Count vulnerabilities by severity
      for (const vuln of vulnerabilities) {
        const severity = this.extractSeverity(vuln);
        switch (severity) {
          case 'CRITICAL':
            counts.critical++;
            break;
          case 'HIGH':
            counts.high++;
            break;
          case 'MEDIUM':
            counts.medium++;
            break;
          case 'LOW':
            counts.low++;
            break;
          default:
            counts.low++; // Default to low if severity is unknown
        }
      }

      this.logger.log(`üîç Found ${counts.total} vulnerabilities for ${packageName}@${version}: ${counts.critical}C ${counts.high}H ${counts.medium}M ${counts.low}L`);
      return counts;
    } catch (error) {
      this.logger.error(`‚ùå Failed to fetch OSV vulnerabilities for ${packageName}@${version}:`, error);
      return { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
    }
  }

  /**
   * Extract severity from OSV vulnerability data
   */
  private extractSeverity(vuln: any): string {
    // Check severity field first
    if (vuln.severity && vuln.severity.length > 0) {
      return vuln.severity[0].score.toUpperCase();
    }

    // Check database_specific for severity
    if (vuln.database_specific?.severity) {
      return vuln.database_specific.severity.toUpperCase();
    }

    // Check for CVSS score and map to severity
    if (vuln.severity && vuln.severity.length > 0) {
      const score = vuln.severity[0].score;
      if (score >= 9.0) return 'CRITICAL';
      if (score >= 7.0) return 'HIGH';
      if (score >= 4.0) return 'MEDIUM';
      return 'LOW';
    }

    return 'LOW'; // Default to low severity
  }

  /**
   * Store package version with vulnerability counts
   */
  async storePackageVersion(
    packageId: string,
    version: string,
    releaseDate: Date,
    vulnerabilityCounts: VulnerabilityCounts
  ): Promise<void> {
    try {
      await this.prisma.packageVersion.upsert({
        where: {
          package_id_version: {
            package_id: packageId,
            version: version
          }
        },
        update: {
          release_date: releaseDate,
          vulnerability_count: vulnerabilityCounts.total,
          critical_count: vulnerabilityCounts.critical,
          high_count: vulnerabilityCounts.high,
          medium_count: vulnerabilityCounts.medium,
          low_count: vulnerabilityCounts.low,
          last_checked: new Date()
        },
        create: {
          package_id: packageId,
          version: version,
          release_date: releaseDate,
          vulnerability_count: vulnerabilityCounts.total,
          critical_count: vulnerabilityCounts.critical,
          high_count: vulnerabilityCounts.high,
          medium_count: vulnerabilityCounts.medium,
          low_count: vulnerabilityCounts.low,
          last_checked: new Date()
        }
      });

      this.logger.log(`üíæ Stored version ${version} for package ${packageId} with ${vulnerabilityCounts.total} vulnerabilities`);
    } catch (error) {
      this.logger.error(`‚ùå Failed to store package version ${version} for package ${packageId}:`, error);
      throw error;
    }
  }

  /**
   * Process vulnerabilities for a package (fetch versions + check vulnerabilities)
   */
  async processPackageVulnerabilities(packageId: string, packageName: string): Promise<void> {
    try {
      this.logger.log(`üîç Processing vulnerabilities for package: ${packageName}`);

      // Fetch versions from NPM
      const versions = await this.fetchNpmVersions(packageName);
      if (versions.length === 0) {
        this.logger.warn(`‚ö†Ô∏è No versions found for package: ${packageName}`);
        return;
      }

      // Process each version
      for (const versionInfo of versions) {
        try {
          // Fetch vulnerabilities for this version
          const vulnerabilityCounts = await this.fetchOsvVulnerabilities(packageName, versionInfo.version);
          
          // Store the version with vulnerability data
          await this.storePackageVersion(
            packageId,
            versionInfo.version,
            versionInfo.releaseDate,
            vulnerabilityCounts
          );

          // Add small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (versionError) {
          this.logger.error(`‚ùå Failed to process version ${versionInfo.version} for ${packageName}:`, versionError);
          // Continue with other versions
        }
      }

      this.logger.log(`‚úÖ Completed vulnerability processing for package: ${packageName}`);
    } catch (error) {
      this.logger.error(`‚ùå Failed to process vulnerabilities for package ${packageName}:`, error);
      throw error;
    }
  }

  /**
   * Get package versions with vulnerability data
   */
  async getPackageVersions(packageId: string, limit: number = 3): Promise<any[]> {
    try {
      const versions = await this.prisma.packageVersion.findMany({
        where: { package_id: packageId },
        orderBy: { release_date: 'desc' },
        take: limit
      });

      return versions;
    } catch (error) {
      this.logger.error(`‚ùå Failed to get package versions for package ${packageId}:`, error);
      return [];
    }
  }
}
