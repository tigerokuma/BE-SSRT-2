import { Injectable } from '@nestjs/common';
import axios from 'axios';

export interface OsvVulnerabilityRange {
  type: string;
  events: Array<{
    introduced?: string;
    fixed?: string;
    last_affected?: string;
    limit?: string;
  }>;
}

export interface OsvVulnerability {
  id: string;
  summary: string;
  severity?: string;
  details?: string;
  affected_versions?: string[];
  fixed_versions?: string[];
  introduced_versions?: string[];
  last_affected_versions?: string[];
  is_patched?: boolean;
  patch_age_days?: number;
  references?: { type: string; url: string }[];
  published?: Date;    // When vulnerability was first published
  modified?: Date;     // When vulnerability was last updated
}

@Injectable()
export class OsvVulnerabilityService {
  private readonly osvApiUrl = 'https://api.osv.dev/v1/query';
  
  // Configuration for filtering old vulnerabilities
  private readonly maxPatchAgeDays = 365 * 2; // 2 years
  private readonly maxVulnerabilityAgeDays = 365 * 5; // 5 years

  async getNpmVulnerabilities(packageName: string, filterOld: boolean = true): Promise<OsvVulnerability[]> {
    try {
      const res = await axios.post(this.osvApiUrl, {
        package: { name: packageName, ecosystem: 'npm' }
      });
      if (!res.data.vulns) return [];
      
      let vulnerabilities = res.data.vulns.map((vuln: any) => this.parseVulnerability(vuln));
      
      if (filterOld) {
        vulnerabilities = vulnerabilities.filter(vuln => this.isRelevantVulnerability(vuln));
      }
      
      return vulnerabilities;
    } catch (e) {
      return [];
    }
  }

  private parseVulnerability(vuln: any): OsvVulnerability {
    const ranges: OsvVulnerabilityRange[] = vuln.affected?.flatMap((a: any) => a.ranges || []) || [];
    
    // Extract different types of version information
    const fixedVersions = this.extractVersions(ranges, 'fixed');
    const introducedVersions = this.extractVersions(ranges, 'introduced');
    const lastAffectedVersions = this.extractVersions(ranges, 'last_affected');
    
    // Determine if vulnerability is patched and when
    const isPatchedInfo = this.analyzePatchStatus(vuln, fixedVersions);
    
    return {
      id: vuln.id,
      summary: vuln.summary,
      severity: vuln.severity?.[0]?.type ? `${vuln.severity[0].type}: ${vuln.severity[0].score}` : undefined,
      details: vuln.details,
      affected_versions: vuln.affected?.flatMap((a: any) => a.ranges?.flatMap((r: any) => r.events?.map((e: any) => e.introduced || e.fixed || e.last_affected || e.limit)).filter(Boolean)) || [],
      fixed_versions: fixedVersions,
      introduced_versions: introducedVersions,
      last_affected_versions: lastAffectedVersions,
      is_patched: isPatchedInfo.isPatched,
      patch_age_days: isPatchedInfo.patchAgeDays,
      references: vuln.references || [],
      published: vuln.published ? new Date(vuln.published) : undefined,
      modified: vuln.modified ? new Date(vuln.modified) : undefined
    };
  }

  private extractVersions(ranges: OsvVulnerabilityRange[], eventType: 'fixed' | 'introduced' | 'last_affected'): string[] {
    return ranges
      .flatMap(range => range.events || [])
      .map(event => event[eventType])
      .filter(Boolean) as string[];
  }

  private analyzePatchStatus(vuln: any, fixedVersions: string[]): { isPatched: boolean; patchAgeDays?: number } {
    // If there are fixed versions, the vulnerability is considered patched
    const isPatched = fixedVersions.length > 0;
    
    if (!isPatched) {
      return { isPatched: false };
    }

    // Calculate patch age based on the modification date (when fix was last updated)
    const modifiedDate = vuln.modified ? new Date(vuln.modified) : null;
    if (modifiedDate) {
      const daysSinceModified = Math.floor((Date.now() - modifiedDate.getTime()) / (1000 * 60 * 60 * 24));
      return { isPatched: true, patchAgeDays: daysSinceModified };
    }

    return { isPatched: true };
  }

  private isRelevantVulnerability(vuln: OsvVulnerability): boolean {
    const now = Date.now();
    
    // Always include unpatched vulnerabilities
    if (!vuln.is_patched) {
      return true;
    }

    // Filter out very old patched vulnerabilities
    if (vuln.patch_age_days && vuln.patch_age_days > this.maxPatchAgeDays) {
      return false;
    }

    // Filter out very old vulnerabilities based on publication date
    if (vuln.published) {
      const daysSincePublished = Math.floor((now - vuln.published.getTime()) / (1000 * 60 * 60 * 24));
      if (daysSincePublished > this.maxVulnerabilityAgeDays) {
        return false;
      }
    }

    // Keep high severity vulnerabilities even if older
    if (vuln.severity?.toLowerCase().includes('critical') || vuln.severity?.toLowerCase().includes('high')) {
      return true;
    }

    return true;
  }

  // Method to get all vulnerabilities without filtering (for debugging/analysis)
  async getAllNpmVulnerabilities(packageName: string): Promise<OsvVulnerability[]> {
    return this.getNpmVulnerabilities(packageName, false);
  }

  // Method to get vulnerability statistics
  async getVulnerabilityStats(packageName: string): Promise<{
    total: number;
    relevant: number;
    patched: number;
    unpatched: number;
    oldPatched: number;
  }> {
    const allVulns = await this.getAllNpmVulnerabilities(packageName);
    const relevantVulns = await this.getNpmVulnerabilities(packageName, true);
    
    const patched = allVulns.filter(v => v.is_patched).length;
    const unpatched = allVulns.filter(v => !v.is_patched).length;
    const oldPatched = allVulns.filter(v => 
      v.is_patched && v.patch_age_days && v.patch_age_days > this.maxPatchAgeDays
    ).length;

    return {
      total: allVulns.length,
      relevant: relevantVulns.length,
      patched,
      unpatched,
      oldPatched
    };
  }
} 