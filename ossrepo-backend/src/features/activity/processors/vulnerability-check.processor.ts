import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { VulnerabilityService } from '../services/vulnerability.service';
import { AlertingService } from '../services/alerting.service';

interface VulnerabilityCheckJobData {
  watchlistId?: string;
}

@Processor('vulnerability-check')
export class VulnerabilityCheckProcessor {
  private readonly logger = new Logger(VulnerabilityCheckProcessor.name);
  private isProcessingWeeklyCheck = false;

  constructor(
    private readonly prisma: PrismaService,
    private readonly vulnerabilityService: VulnerabilityService,
    private readonly alertingService: AlertingService,
    @InjectQueue('vulnerability-check') private readonly vulnerabilityQueue: Queue,
  ) {}

  async initializeVulnerabilityCheckSchedule() {
    this.logger.log('üöÄ Initializing vulnerability check schedule...');
    
    try {
      await this.vulnerabilityQueue.add(
        'weekly-vulnerability-check',
        {},
        {
          attempts: 1,
          removeOnComplete: 10,
          removeOnFail: 50,
        },
      );
      
      this.logger.log('‚úÖ Added immediate vulnerability check job to make queue visible');
      await this.initializeWeeklyVulnerabilityCheck();
    } catch (error) {
      this.logger.error('Error initializing vulnerability check schedule:', error);
      throw error;
    }
  }

  async triggerWeeklyVulnerabilityCheck() {
    if (this.isProcessingWeeklyCheck) {
      this.logger.log('‚è≥ Weekly vulnerability check already in progress, skipping...');
      return;
    }

    this.isProcessingWeeklyCheck = true;

    this.logger.log(
      `\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nüîç WEEKLY VULNERABILITY CHECK TRIGGERED\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
    );

    try {
      const watchlistedRepos = await this.prisma.watchlist.findMany({
        where: { status: 'ready' },
        select: {
          watchlist_id: true,
          package: {
            select: {
              repo_url: true,
              repo_name: true,
              package_name: true,
            }
          },
        },
      });

      this.logger.log(`Found ${watchlistedRepos.length} ready repositories to check for vulnerabilities`);

      let processedCount = 0;
      let newCriticalVulnerabilitiesFound = 0;

      for (const repo of watchlistedRepos) {
        const { repo_url, repo_name, package_name } = repo.package;
        
        if (!repo_url) {
          this.logger.warn(`No repo URL found for ${repo_name}, skipping`);
          continue;
        }

        try {
          const newVulnerabilities = await this.checkRepositoryVulnerabilities(
            repo.watchlist_id,
            package_name,
            repo_url,
            repo_name
          );
          
          if (newVulnerabilities > 0) {
            newCriticalVulnerabilitiesFound += newVulnerabilities;
          }
          
          processedCount++;
          
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (error) {
          this.logger.error(`Error checking vulnerabilities for ${repo_name}:`, error);
        }
      }

      this.logger.log(`‚úÖ Completed vulnerability check for ${processedCount}/${watchlistedRepos.length} repositories`);
      this.logger.log(`üö® Found ${newCriticalVulnerabilitiesFound} new critical vulnerabilities across all repositories`);

      await this.scheduleNextWeeklyVulnerabilityCheck();
    } catch (error) {
      this.logger.error('Error during weekly vulnerability check trigger:', error);
    } finally {
      this.isProcessingWeeklyCheck = false;
    }
  }

  private async checkRepositoryVulnerabilities(
    watchlistId: string,
    packageName: string,
    repoUrl: string,
    repoName: string
  ): Promise<number> {
    try {
      this.logger.log(`üîç Checking vulnerabilities for ${repoName} (${packageName})`);

      const currentVulnerabilities = await this.vulnerabilityService.getVulnerabilities(watchlistId);
      const currentCriticalCount = currentVulnerabilities?.summary.criticalCount || 0;

      const newVulnerabilities = await this.vulnerabilityService.fetchVulnerabilities(packageName, repoUrl);
      
      if (newVulnerabilities.length === 0) {
        this.logger.log(`‚úÖ No vulnerabilities found for ${repoName}`);
        return 0;
      }

      const summary = this.vulnerabilityService.generateVulnerabilitySummary(newVulnerabilities);
      await this.vulnerabilityService.storeVulnerabilities(watchlistId, newVulnerabilities, summary);

      const newCriticalCount = summary.criticalCount;
      const newCriticalVulnerabilities = newCriticalCount - currentCriticalCount;

      if (newCriticalVulnerabilities > 0) {
        this.logger.log(`üö® Found ${newCriticalVulnerabilities} new critical vulnerabilities for ${repoName}`);
        await this.createVulnerabilityAlerts(watchlistId, newVulnerabilities, repoName);
        return newCriticalVulnerabilities;
      } else {
        this.logger.log(`‚úÖ No new critical vulnerabilities found for ${repoName}`);
        return 0;
      }
    } catch (error) {
      this.logger.error(`Error checking vulnerabilities for ${repoName}:`, error);
      return 0;
    }
  }

  private async createVulnerabilityAlerts(
    watchlistId: string,
    vulnerabilities: any[],
    repoName: string
  ): Promise<void> {
    try {
      const userWatchlists = await this.prisma.userWatchlist.findMany({
        where: { watchlist_id: watchlistId },
        select: {
          id: true,
          user_id: true,
          alerts: true,
        },
      });

      if (userWatchlists.length === 0) {
        this.logger.log(`No users watching repository ${watchlistId}`);
        return;
      }

      const criticalVulnerabilities = vulnerabilities.filter(v => v.severity === 'CRITICAL');

      for (const vulnerability of criticalVulnerabilities) {
        for (const userWatchlist of userWatchlists) {
          let alertSettings;
          try {
            alertSettings = userWatchlist.alerts ? JSON.parse(userWatchlist.alerts) : {};
          } catch (parseError) {
            this.logger.warn(`Failed to parse alert settings for user ${userWatchlist.user_id}, using default settings`);
            alertSettings = {};
          }

          if (alertSettings.new_vulnerabilities_detected?.enabled) {
            await this.createVulnerabilityAlert(
              userWatchlist.id,
              watchlistId,
              vulnerability,
              repoName
            );
            this.logger.log(`‚úÖ Vulnerability alert created for user ${userWatchlist.user_id} (alerts enabled)`);
          } else {
            this.logger.log(`‚è≠Ô∏è Skipping vulnerability alert for user ${userWatchlist.user_id} (alerts disabled)`);
          }
        }
      }
    } catch (error) {
      this.logger.error(`Error creating vulnerability alerts for ${repoName}:`, error);
    }
  }

  private async createVulnerabilityAlert(
    userWatchlistId: string,
    watchlistId: string,
    vulnerability: any,
    repoName: string
  ): Promise<void> {
    try {
      const details = {
        vulnerability: {
          id: vulnerability.id,
          title: vulnerability.title,
          description: vulnerability.description,
          severity: vulnerability.severity,
          cveId: vulnerability.cveId,
          ghsaId: vulnerability.ghsaId,
          publishedDate: vulnerability.publishedDate,
          affectedVersions: vulnerability.affectedVersions,
          fixedVersions: vulnerability.fixedVersions,
          references: vulnerability.references,
        },
        repository: {
          name: repoName,
          watchlistId: watchlistId,
        },
      };

      await this.prisma.alertTriggered.create({
        data: {
          user_watchlist_id: userWatchlistId,
          watchlist_id: watchlistId,
          commit_sha: 'vulnerability-check',
          contributor: 'security-system',
          metric: 'critical_vulnerability_detected',
          value: 1,
          alert_level: 'critical',
          threshold_type: 'vulnerability_check',
          threshold_value: 0,
          description: `Critical vulnerability detected in ${repoName}: ${vulnerability.title}`,
          details_json: details,
        },
      });

      this.logger.log(`üö® VULNERABILITY ALERT CREATED: ${vulnerability.title} - ${repoName}`);
    } catch (error) {
      this.logger.error(`Error creating vulnerability alert:`, error);
    }
  }

  private async scheduleNextWeeklyVulnerabilityCheck(): Promise<void> {
    try {
      const waitingJobs = await this.vulnerabilityQueue.getWaiting();
      const existingWeeklyCheckJob = waitingJobs.find(job => job.name === 'weekly-vulnerability-check');
      
      if (existingWeeklyCheckJob) {
        this.logger.log('üìÖ Weekly vulnerability check job already scheduled, skipping duplicate');
        return;
      }

      const now = new Date();
      const nextWeek = new Date(now);
      nextWeek.setDate(nextWeek.getDate() + 7);
      nextWeek.setHours(0, 0, 0, 0);
      
      const delayMs = nextWeek.getTime() - now.getTime();
      
      await this.vulnerabilityQueue.add(
        'weekly-vulnerability-check',
        {},
        {
          delay: delayMs,
          attempts: 1,
          removeOnComplete: 10,
          removeOnFail: 50,
        },
      );

      this.logger.log(`üìÖ Scheduled next weekly vulnerability check for ${nextWeek.toISOString()}`);
    } catch (error) {
      this.logger.error('Error scheduling next weekly vulnerability check:', error);
    }
  }

  private async initializeWeeklyVulnerabilityCheck(): Promise<void> {
    try {
      const waitingJobs = await this.vulnerabilityQueue.getWaiting();
      const weeklyCheckJob = waitingJobs.find(job => job.name === 'weekly-vulnerability-check');
      
      if (!weeklyCheckJob) {
        this.logger.log('üöÄ Initializing weekly vulnerability check schedule...');
        await this.scheduleNextWeeklyVulnerabilityCheck();
      } else {
        this.logger.log('üìÖ Weekly vulnerability check schedule already exists');
      }
    } catch (error) {
      this.logger.error('Error initializing weekly vulnerability check:', error);
    }
  }

  @Process('weekly-vulnerability-check')
  async handleWeeklyVulnerabilityCheck(job: Job) {
    this.logger.log('üïõ Weekly vulnerability check job triggered');
    await this.triggerWeeklyVulnerabilityCheck();
  }

  @Process('check-single-repository')
  async handleSingleRepositoryCheck(job: Job<VulnerabilityCheckJobData>) {
    const { watchlistId } = job.data;
    
    if (!watchlistId) {
      this.logger.error('No watchlistId provided for single repository vulnerability check');
      return;
    }

    this.logger.log(`üîç Single repository vulnerability check triggered for ${watchlistId}`);

    try {
      const watchlist = await this.prisma.watchlist.findUnique({
        where: { watchlist_id: watchlistId },
        include: {
          package: {
            select: {
              repo_url: true,
              repo_name: true,
              package_name: true,
            }
          }
        }
      });

      if (!watchlist?.package) {
        this.logger.error(`No package found for watchlist ${watchlistId}`);
        return;
      }

      const { repo_url, repo_name, package_name } = watchlist.package;
      
      if (!repo_url) {
        this.logger.error(`No repo URL found for watchlist ${watchlistId}`);
        return;
      }

      await this.checkRepositoryVulnerabilities(watchlistId, package_name, repo_url, repo_name);
    } catch (error) {
      this.logger.error(`Error in single repository vulnerability check for ${watchlistId}:`, error);
    }
  }
}
